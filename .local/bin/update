#!/bin/bash

# Fedora & Flatpak Update Script
# A friendly and versatile system updater
# Place in ~/.local/bin/update and make executable with: chmod +x ~/.local/bin/update

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'
DIM='\033[2m'

# Configuration
SKIP_DNF=false
SKIP_FLATPAK=false
AUTO_REBOOT=false
DRY_RUN=false
QUIET=false
CHECK_ONLY=false
CLEANUP=false
VERBOSE=false
START_TIME=$(date +%s)

# Function to print colored messages
print_header() {
  echo -e "\n${BOLD}${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
  echo -e "${BOLD}${BLUE}â•‘${NC}  ${BOLD}${CYAN}$1${NC}"
  echo -e "${BOLD}${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
}

print_section() {
  echo -e "\n${BOLD}${MAGENTA}â–¶${NC} ${BOLD}$1${NC}"
  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
}

print_success() {
  echo -e "${GREEN}âœ“${NC} $1"
}

print_error() {
  echo -e "${RED}âœ—${NC} $1" >&2
}

print_warning() {
  echo -e "${YELLOW}âš ${NC}  $1"
}

print_info() {
  echo -e "${CYAN}â†’${NC} $1"
}

print_step() {
  echo -e "${BLUE}â—†${NC} $1"
}

print_stats() {
  echo -e "${DIM}  â”œâ”€${NC} $1"
}

# Display a nice banner
show_banner() {
  cat <<"EOF"
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                          â•‘
    â•‘     ğŸš€  System Update Manager  ğŸš€        â•‘
    â•‘                                          â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
}

# Calculate and show elapsed time
show_elapsed_time() {
  local end_time=$(date +%s)
  local elapsed=$((end_time - START_TIME))
  local minutes=$((elapsed / 60))
  local seconds=$((elapsed % 60))

  if [ $minutes -gt 0 ]; then
    echo -e "${DIM}â±  Completed in ${minutes}m ${seconds}s${NC}"
  else
    echo -e "${DIM}â±  Completed in ${seconds}s${NC}"
  fi
}

# Display updating packages in a nice column format
display_package_list() {
  local packages="$1"
  local max_display=15
  local count=$(echo "$packages" | grep -v "^$" | wc -l)
  
  if [ $count -eq 0 ]; then
    return
  fi
  
  echo ""
  echo -e "${BOLD}${DIM}Packages being updated:${NC}"
  
  # Display first packages in columns
  echo "$packages" | grep -v "^$" | head -n $max_display | while read -r pkg; do
    echo -e "  ${DIM}â€¢${NC} ${CYAN}$pkg${NC}"
  done
  
  # If more than max_display, show count of remaining
  if [ $count -gt $max_display ]; then
    local remaining=$((count - max_display))
    echo -e "  ${DIM}... and $remaining more${NC}"
  fi
  echo ""
}

# Animated progress bar that pulses
animate_progress() {
  local message="$1"
  local pid="$2"
  local width=40
  local pos=0
  local direction=1
  
  tput civis # Hide cursor
  
  while kill -0 $pid 2>/dev/null; do
    # Create progress bar with moving highlight
    local bar=""
    for ((i=0; i<width; i++)); do
      if [ $i -eq $pos ] || [ $i -eq $((pos-1)) ] || [ $i -eq $((pos+1)) ]; then
        bar="${bar}â”"
      else
        bar="${bar}â”€"
      fi
    done
    
    printf "\r  ${CYAN}${message}${NC} ${BLUE}[${bar}]${NC}"
    
    # Move position
    pos=$((pos + direction))
    if [ $pos -ge $width ]; then
      pos=$((width - 2))
      direction=-1
    elif [ $pos -lt 0 ]; then
      pos=1
      direction=1
    fi
    
    sleep 0.08
  done
  
  tput cnorm # Show cursor
  printf "\r%*s\r" $((${#message} + width + 10)) ""
}

# Real progress bar with percentage tracking
show_real_progress() {
  local message="$1"
  local pid="$2"
  local log_file="$3"
  local total="$4"
  local width=40
  
  if [ "$total" -eq 0 ]; then
    # Fallback to animated progress if we don't know total
    animate_progress "$message" "$pid"
    return
  fi
  
  tput civis # Hide cursor
  local completed=0
  local last_completed=0
  
  while kill -0 $pid 2>/dev/null; do
    # Count completed packages from log
    if [ -f "$log_file" ]; then
      # Look for various completion indicators in DNF output
      completed=$(grep -c -E "(Installing|Upgrading|Cleanup|Verifying|Complete!)" "$log_file" 2>/dev/null | tr -d '\n' || echo "0")
      
      # Ensure completed is a valid number
      if ! [[ "$completed" =~ ^[0-9]+$ ]]; then
        completed=0
      fi
      
      # Cap at total to avoid over 100%
      if [ "$completed" -gt "$total" ]; then
        completed=$total
      fi
    fi
    
    local percentage=$((completed * 100 / total))
    local filled=$((width * completed / total))
    local empty=$((width - filled))
    
    # Build progress bar
    local bar=""
    for ((i=0; i<filled; i++)); do
      bar="${bar}â–ˆ"
    done
    for ((i=0; i<empty; i++)); do
      bar="${bar}â–‘"
    done
    
    printf "\r  ${CYAN}${message}${NC} ${BLUE}[${bar}]${NC} ${BOLD}%3d%%${NC} ${DIM}(%d/%d)${NC}" "$percentage" "$completed" "$total"
    
    sleep 0.3
  done
  
  # Show 100% when complete
  local bar=""
  for ((i=0; i<width; i++)); do
    bar="${bar}â–ˆ"
  done
  printf "\r  ${CYAN}${message}${NC} ${GREEN}[${bar}]${NC} ${BOLD}100%%${NC} ${DIM}(%d/%d)${NC}\n" "$total" "$total"
  
  tput cnorm # Show cursor
}

# Function to show usage
show_help() {
  printf "${BOLD}${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"
  printf "â•‘          Fedora & Flatpak Update Script                   â•‘\n"
  printf "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n\n"

  printf "${BOLD}USAGE:${NC}\n"
  printf "    ${GREEN}update${NC} ${DIM}[OPTIONS]${NC}\n\n"

  printf "${BOLD}COMMON OPTIONS:${NC}\n"
  printf "    ${GREEN}-h${NC}, ${GREEN}--help${NC}              Show this help message\n"
  printf "    ${GREEN}-c${NC}, ${GREEN}--check${NC}             Check for updates without installing\n"
  printf "    ${GREEN}-C${NC}, ${GREEN}--cleanup${NC}           Update everything and cleanup old packages\n"
  printf "    ${GREEN}-n${NC}, ${GREEN}--dry-run${NC}           Preview what would be updated\n"
  printf "    ${GREEN}-q${NC}, ${GREEN}--quiet${NC}             Minimal output mode\n"
  printf "    ${GREEN}-v${NC}, ${GREEN}--verbose${NC}           Show detailed DNF/Flatpak output\n\n"

  printf "${BOLD}SELECTIVE UPDATES:${NC}\n"
  printf "    ${GREEN}-d${NC}, ${GREEN}--skip-dnf${NC}          Skip system (DNF) updates\n"
  printf "    ${GREEN}-f${NC}, ${GREEN}--skip-flatpak${NC}      Skip Flatpak updates\n\n"

  printf "${BOLD}ADVANCED OPTIONS:${NC}\n"
  printf "    ${GREEN}-r${NC}, ${GREEN}--reboot${NC}            Auto-reboot if kernel was updated\n"
  printf "    ${GREEN}-y${NC}, ${GREEN}--yes${NC}               Skip all confirmations (use with caution)\n\n"

  printf "${BOLD}EXAMPLES:${NC}\n"
  printf "    ${CYAN}update${NC}                   ${DIM}# Update everything (clean output)${NC}\n"
  printf "    ${CYAN}update -v${NC}                ${DIM}# Update with full DNF/Flatpak output${NC}\n"
  printf "    ${CYAN}update -c${NC}                ${DIM}# Check what updates are available${NC}\n"
  printf "    ${CYAN}update -C${NC}                ${DIM}# Update + cleanup old packages${NC}\n"
  printf "    ${CYAN}update -d${NC}                ${DIM}# Update only Flatpak apps${NC}\n"
  printf "    ${CYAN}update -f${NC}                ${DIM}# Update only system packages${NC}\n"
  printf "    ${CYAN}update -n${NC}                ${DIM}# Dry run (see what would update)${NC}\n"
  printf "    ${CYAN}update -r${NC}                ${DIM}# Update and reboot if needed${NC}\n\n"

  printf "${BOLD}NOTES:${NC}\n"
  printf "    ${YELLOW}â€¢${NC} Requires sudo privileges for system updates\n"
  printf "    ${YELLOW}â€¢${NC} Creates a detailed log at ${DIM}/tmp/update-script.log${NC}\n"
  printf "    ${YELLOW}â€¢${NC} Use ${GREEN}-v${NC} flag to see full output from DNF and Flatpak\n"
  printf "    ${YELLOW}â€¢${NC} Reboot recommended after kernel updates\n\n"

  printf "${DIM}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"
  printf "${DIM}For issues or suggestions, check the log file or your system logs${NC}\n\n"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
  -h | --help)
    show_help
    exit 0
    ;;
  -d | --skip-dnf)
    SKIP_DNF=true
    shift
    ;;
  -f | --skip-flatpak)
    SKIP_FLATPAK=true
    shift
    ;;
  -c | --check)
    CHECK_ONLY=true
    shift
    ;;
  -n | --dry-run)
    DRY_RUN=true
    shift
    ;;
  -q | --quiet)
    QUIET=true
    shift
    ;;
  -v | --verbose)
    VERBOSE=true
    shift
    ;;
  -r | --reboot)
    AUTO_REBOOT=true
    shift
    ;;
  -C | --cleanup)
    CLEANUP=true
    shift
    ;;
  -a | --all)
    CLEANUP=true
    shift
    ;;
  -y | --yes)
    # This will be used to skip confirmations in the future
    shift
    ;;
  *)
    print_error "Unknown option: $1"
    echo -e "${DIM}Use '${GREEN}update --help${DIM}' for usage information${NC}"
    exit 1
    ;;
  esac
done

# Log file
LOGFILE="/tmp/update-script.log"
: > "$LOGFILE"  # Clear previous log
exec > >(tee -a "$LOGFILE") 2>&1

# Start
if [ "$QUIET" = false ]; then
  clear
  show_banner
  echo -e "${DIM}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${BOLD}Started:${NC} ${CYAN}$(date '+%A, %B %d, %Y at %I:%M %p')${NC}"

  # Show what will be updated
  echo -e "\n${BOLD}${MAGENTA}Plan:${NC}"
  if [ "$CHECK_ONLY" = true ]; then
    print_info "Checking for available updates..."
  elif [ "$DRY_RUN" = true ]; then
    print_info "Performing dry run (no actual changes)..."
  else
    [ "$SKIP_DNF" = false ] && print_step "System packages (DNF)"
    [ "$SKIP_FLATPAK" = false ] && print_step "Flatpak applications"
    [ "$CLEANUP" = true ] && print_step "Cleanup old packages"
  fi

  echo -e "\n${DIM}Log file: $LOGFILE${NC}"
  if [ "$VERBOSE" = false ]; then
    echo -e "${DIM}Tip: Use -v flag for detailed output${NC}"
  fi
  echo -e "${DIM}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}\n"

  # Small pause for readability
  sleep 0.5
fi

# Check if running with appropriate permissions
if [ "$SKIP_DNF" = false ] && [ "$EUID" -eq 0 ]; then
  print_warning "Running as root. This is not recommended."
  print_info "The script will use sudo when needed."
fi

# DNF/System Updates
if [ "$SKIP_DNF" = false ]; then
  print_header "System Updates (DNF)"

  if [ "$CHECK_ONLY" = true ]; then
    print_info "Checking for system updates..."

    # Get list of packages to update
    TEMP_CHECK=$(mktemp)
    sudo dnf check-update -q 2>/dev/null > "$TEMP_CHECK" || true
    PACKAGE_LIST=$(awk '{print $1}' "$TEMP_CHECK" | grep -v "^$" | grep -v "Last" | grep -v "Fedora" | grep -v "^Security" | grep -v "^Bugfix" | sort -u)
    UPDATE_COUNT=$(echo "$PACKAGE_LIST" | grep -v "^$" | wc -l)

    if [ "$UPDATE_COUNT" -gt 0 ]; then
      print_warning "$UPDATE_COUNT package(s) available for update"
      if [ "$VERBOSE" = true ]; then
        echo ""
        cat "$TEMP_CHECK"
      else
        display_package_list "$PACKAGE_LIST"
      fi
    else
      print_success "System is up to date!"
    fi
    rm -f "$TEMP_CHECK"

  elif [ "$DRY_RUN" = true ]; then
    print_info "Dry run: Checking what would be updated..."
    
    # Get clean list of packages
    TEMP_FILE=$(mktemp)
    sudo dnf check-update -q 2>/dev/null > "$TEMP_FILE" || true
    # Filter out all header/metadata lines and only keep package names
    PACKAGE_LIST=$(cat "$TEMP_FILE" | \
      grep -v "^$" | \
      grep -v "Last metadata" | \
      grep -v "^Fedora" | \
      grep -v "^Security" | \
      grep -v "^Bugfix" | \
      grep -v "Obsoleting" | \
      grep -v "^Upgrading" | \
      grep -v "^Installing" | \
      grep -v "packages$" | \
      awk '{print $1}' | \
      grep -v "^[0-9]*$" | \
      sort -u)
    UPDATE_COUNT=$(echo "$PACKAGE_LIST" | grep -v "^$" | wc -l)
    
    if [ "$UPDATE_COUNT" -gt 0 ]; then
      print_warning "$UPDATE_COUNT package(s) would be updated"
      display_package_list "$PACKAGE_LIST"
    else
      print_success "No updates available"
    fi
    
    rm -f "$TEMP_FILE"
    
    if [ "$VERBOSE" = true ]; then
      echo ""
      echo -e "${DIM}Full DNF output:${NC}"
      sudo dnf upgrade --refresh --assumeno 2>/dev/null || true
    fi

  else
    print_info "Checking for updates..."

    # Check for updates first to show count and list
    TEMP_FILE=$(mktemp)
    sudo dnf check-update -q 2>/dev/null > "$TEMP_FILE" || true
    # Filter out all header/metadata lines and only keep package names
    PACKAGE_LIST=$(cat "$TEMP_FILE" | \
      grep -v "^$" | \
      grep -v "Last metadata" | \
      grep -v "^Fedora" | \
      grep -v "^Security" | \
      grep -v "^Bugfix" | \
      grep -v "Obsoleting" | \
      grep -v "^Upgrading" | \
      grep -v "^Installing" | \
      grep -v "packages$" | \
      awk '{print $1}' | \
      grep -v "^[0-9]*$" | \
      sort -u)
    UPDATE_COUNT=$(echo "$PACKAGE_LIST" | grep -v "^$" | wc -l)

    if [ "$UPDATE_COUNT" -eq 0 ]; then
      print_success "System is already up to date!"
      rm -f "$TEMP_FILE"
    else
      print_info "Found $UPDATE_COUNT package(s) to update"
      
      # Display package names in clean list (always show, unless verbose)
      if [ "$VERBOSE" = false ]; then
        display_package_list "$PACKAGE_LIST"
      fi
      rm -f "$TEMP_FILE"

      if [ "$VERBOSE" = true ]; then
        # Show full output
        echo ""
        sudo dnf upgrade --refresh -y
      else
        # Clean output with progress bar
        TEMP_OUTPUT=$(mktemp)
        sudo dnf upgrade --refresh -y > "$TEMP_OUTPUT" 2>&1 &
        DNF_PID=$!
        
        show_real_progress "Updating system packages" $DNF_PID "$TEMP_OUTPUT" $UPDATE_COUNT
        wait $DNF_PID
        DNF_EXIT=$?
        
        rm -f "$TEMP_OUTPUT"
        
        if [ $DNF_EXIT -eq 0 ]; then
          print_success "System packages updated successfully!"
        else
          print_error "Update failed! Check log for details: $LOGFILE"
        fi
      fi

      # Show some stats
      if [ "$VERBOSE" = true ]; then
        echo ""
        INSTALLED_COUNT=$(sudo dnf list installed 2>/dev/null | wc -l)
        print_stats "Total packages installed: $INSTALLED_COUNT"
      fi
    fi
  fi
fi

# Flatpak Updates
if [ "$SKIP_FLATPAK" = false ]; then
  if command -v flatpak &>/dev/null; then
    print_header "Flatpak Updates"

    if [ "$CHECK_ONLY" = true ]; then
      print_info "Checking for Flatpak updates..."

      # Get update list with full IDs
      UPDATE_LIST=$(flatpak remote-ls --updates --columns=application 2>/dev/null)
      UPDATE_COUNT=$(echo "$UPDATE_LIST" | grep -v "^$" | wc -l)

      if [ "$UPDATE_COUNT" -gt 0 ]; then
        print_warning "$UPDATE_COUNT Flatpak app(s) available for update"
        if [ "$VERBOSE" = true ]; then
          echo ""
          flatpak remote-ls --updates 2>/dev/null
        else
          display_package_list "$UPDATE_LIST"
        fi
      else
        print_success "All Flatpak apps are up to date!"
      fi

    elif [ "$DRY_RUN" = true ]; then
      print_info "Dry run: Checking what would be updated..."
      
      UPDATE_LIST=$(flatpak remote-ls --updates --columns=application 2>/dev/null)
      UPDATE_COUNT=$(echo "$UPDATE_LIST" | grep -v "^$" | wc -l)
      
      if [ "$UPDATE_COUNT" -gt 0 ]; then
        print_warning "$UPDATE_COUNT Flatpak app(s) would be updated"
        display_package_list "$UPDATE_LIST"
      else
        print_success "No Flatpak updates available"
      fi
      
      if [ "$VERBOSE" = true ]; then
        echo ""
        echo -e "${DIM}Full Flatpak output:${NC}"
        flatpak remote-ls --updates 2>/dev/null
      fi

    else
      # Check for updates first
      print_info "Checking for Flatpak updates..."
      UPDATE_LIST=$(flatpak remote-ls --updates --columns=application 2>/dev/null)
      UPDATE_COUNT=$(echo "$UPDATE_LIST" | grep -v "^$" | wc -l)

      if [ "$UPDATE_COUNT" -eq 0 ]; then
        print_success "All Flatpak apps are up to date!"
      else
        print_info "Found $UPDATE_COUNT Flatpak application(s) to update"
        
        # Display app IDs
        if [ "$VERBOSE" = false ]; then
          display_package_list "$UPDATE_LIST"
        fi

        if [ "$VERBOSE" = true ]; then
          # Show full output
          echo ""
          flatpak update -y
        else
          # Clean output with progress bar
          TEMP_OUTPUT=$(mktemp)
          flatpak update -y > "$TEMP_OUTPUT" 2>&1 &
          FLATPAK_PID=$!
          
          show_real_progress "Updating Flatpak applications" $FLATPAK_PID "$TEMP_OUTPUT" $UPDATE_COUNT
          wait $FLATPAK_PID
          FLATPAK_EXIT=$?
          
          rm -f "$TEMP_OUTPUT"
          
          if [ $FLATPAK_EXIT -eq 0 ]; then
            print_success "Flatpak applications updated successfully!"
          else
            print_error "Update failed! Check log for details: $LOGFILE"
          fi
        fi

        # Show stats
        if [ "$VERBOSE" = true ]; then
          echo ""
          APP_COUNT=$(flatpak list --app 2>/dev/null | wc -l)
          print_stats "Total Flatpak apps installed: $APP_COUNT"
        fi
      fi
    fi
  else
    print_warning "Flatpak not found, skipping Flatpak updates"
    print_info "Install Flatpak with: ${CYAN}sudo dnf install flatpak${NC}"
  fi
fi

# Cleanup operations
if [ "$CLEANUP" = true ] && [ "$CHECK_ONLY" = false ] && [ "$DRY_RUN" = false ]; then
  print_header "Cleanup Operations"

  if [ "$SKIP_DNF" = false ]; then
    print_section "DNF Cleanup"

    # Get disk usage before
    CACHE_BEFORE=$(du -sm /var/cache/dnf 2>/dev/null | cut -f1 || echo "0")

    if [ "$VERBOSE" = true ]; then
      print_info "Removing old kernels and unused packages..."
      sudo dnf autoremove -y
      print_info "Cleaning package cache..."
      sudo dnf clean all
    else
      TEMP_OUTPUT=$(mktemp)
      (sudo dnf autoremove -y && sudo dnf clean all) > "$TEMP_OUTPUT" 2>&1 &
      CLEANUP_PID=$!
      
      animate_progress "Cleaning up old packages" $CLEANUP_PID
      wait $CLEANUP_PID
      rm -f "$TEMP_OUTPUT"
    fi

    # Get disk usage after
    CACHE_AFTER=$(du -sm /var/cache/dnf 2>/dev/null | cut -f1 || echo "0")
    SPACE_FREED=$((CACHE_BEFORE - CACHE_AFTER))

    print_success "DNF cleanup completed"
    if [ "$SPACE_FREED" -gt 0 ]; then
      print_stats "Freed approximately ${SPACE_FREED}MB of disk space"
    fi
  fi

  if [ "$SKIP_FLATPAK" = false ] && command -v flatpak &>/dev/null; then
    echo ""
    print_section "Flatpak Cleanup"

    # Check if there are unused runtimes
    UNUSED_CHECK=$(flatpak uninstall --unused --assumeno 2>/dev/null || echo "")
    UNUSED_COUNT=$(echo "$UNUSED_CHECK" | grep -E "^\s+[0-9]" | wc -l)

    if [ "$UNUSED_COUNT" -gt 0 ]; then
      if [ "$VERBOSE" = true ]; then
        print_info "Removing unused Flatpak runtimes..."
        flatpak uninstall --unused -y
      else
        TEMP_OUTPUT=$(mktemp)
        flatpak uninstall --unused -y > "$TEMP_OUTPUT" 2>&1 &
        FLATPAK_CLEANUP_PID=$!
        
        animate_progress "Removing unused runtimes" $FLATPAK_CLEANUP_PID
        wait $FLATPAK_CLEANUP_PID
        rm -f "$TEMP_OUTPUT"
      fi
      print_success "Removed $UNUSED_COUNT unused runtime(s)"
    else
      print_success "No unused Flatpak runtimes found"
    fi
  fi

  echo ""
  print_success "Cleanup completed! ğŸ§¹"
fi

# Check if reboot is needed
if [ "$SKIP_DNF" = false ] && [ "$CHECK_ONLY" = false ] && [ "$DRY_RUN" = false ]; then
  print_header "Post-Update Checks"

  REBOOT_NEEDED=false
  REBOOT_REASON=""

  # Check using needs-restarting if available
  if command -v needs-restarting &>/dev/null; then
    if ! needs-restarting -r &>/dev/null; then
      REBOOT_NEEDED=true
      REBOOT_REASON="System services or kernel updated"
    fi
  else
    # Fallback: check for kernel updates
    CURRENT_KERNEL=$(uname -r)
    LATEST_KERNEL=$(rpm -q kernel --last 2>/dev/null | head -n1 | cut -d' ' -f1 | sed 's/kernel-//' || echo "$CURRENT_KERNEL")

    if [ "$CURRENT_KERNEL" != "$LATEST_KERNEL" ]; then
      REBOOT_NEEDED=true
      REBOOT_REASON="New kernel installed: $LATEST_KERNEL"
    fi
  fi

  if [ "$REBOOT_NEEDED" = true ]; then
    echo ""
    print_warning "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    print_warning "âš ï¸  REBOOT RECOMMENDED"
    print_warning "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    print_info "Reason: $REBOOT_REASON"
    echo ""

    if [ "$AUTO_REBOOT" = true ]; then
      print_warning "Auto-reboot is enabled!"
      echo ""
      for i in {10..1}; do
        echo -ne "\r${YELLOW}â±  Rebooting in ${i} seconds... Press Ctrl+C to cancel ${NC}"
        sleep 1
      done
      echo ""
      echo ""
      print_info "Initiating system reboot..."
      sudo systemctl reboot
    else
      print_info "To reboot now, run: ${GREEN}sudo systemctl reboot${NC}"
      print_info "Or run update with ${GREEN}-r${NC} flag for auto-reboot"
    fi
    echo ""
  else
    print_success "âœ“ No reboot required"
    print_info "System is running the latest kernel"
  fi
fi

# Summary
if [ "$QUIET" = false ]; then
  echo ""
  echo -e "${BOLD}${GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
  echo -e "${BOLD}${GREEN}â•‘                                                   â•‘${NC}"
  echo -e "${BOLD}${GREEN}â•‘        âœ¨  Update Complete!  âœ¨                  â•‘${NC}"
  echo -e "${BOLD}${GREEN}â•‘                                                   â•‘${NC}"
  echo -e "${BOLD}${GREEN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
  echo ""

  echo -e "${BOLD}Summary:${NC}"
  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

  # Show what was done
  if [ "$CHECK_ONLY" = true ]; then
    print_info "Checked for available updates"
  elif [ "$DRY_RUN" = true ]; then
    print_info "Performed dry run (no changes made)"
  else
    [ "$SKIP_DNF" = false ] && print_success "System packages updated"
    [ "$SKIP_FLATPAK" = false ] && print_success "Flatpak apps updated"
    [ "$CLEANUP" = true ] && print_success "Cleanup performed"
  fi

  echo ""
  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  show_elapsed_time
  echo -e "${DIM}Log saved to: $LOGFILE${NC}"
  echo -e "${DIM}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
  echo ""

  # Random encouragement message
  MESSAGES=(
    "Your system is fresh and ready! ğŸ‰"
    "All done! Your system is up to date! ğŸš€"
    "Updates complete! Keep up the good work! â­"
    "System updated successfully! You're all set! âœ¨"
    "Great job keeping your system updated! ğŸŒŸ"
  )
  RANDOM_MSG=${MESSAGES[$RANDOM % ${#MESSAGES[@]}]}
  echo -e "  ${CYAN}${RANDOM_MSG}${NC}"
  echo ""
fi

